{"mappings":"ACQU,CAAA,KAEA,IAAI,oBAAuB,CAE/B,oBACN;;2BAE2B,EACpB,CAAC,wBAAyB,oBAAqB,uBAEtD,KAAK,uwRAEC,EAEA,qBACN;;4BAE4B,EACrB,CAAC,wBAAyB,oBAAqB,uBAEtD,KAAK,olCAEC,CAEI,EAGI,yBAA2B,CAAC,EAGhC,SAAS,oBAAoB,CAAQ,EAEpC,IAAI,EAAe,wBAAwB,CAAC,EAAS,CACrD,GAAI,AAAiB,KAAA,IAAjB,EACH,OAAO,EAAa,OAAO,CAG5B,IAAI,EAAS,wBAAwB,CAAC,EAAS,CAAG,CAGjD,QAAS,CAAC,CACX,EAMA,OAHA,mBAAmB,CAAC,EAAS,CAAC,EAAQ,EAAO,OAAO,CAAE,qBAG/C,EAAO,OAAO,AACtB,CAIC,AAAA,CAAA,KAEA,oBAAoB,CAAC,CAAG,CAAC,EAAS,KACjC,IAAI,IAAI,KAAO,EACX,oBAAoB,CAAC,CAAC,EAAY,IAAQ,CAAC,oBAAoB,CAAC,CAAC,EAAS,IAC5E,OAAO,cAAc,CAAC,EAAS,EAAK,CAAE,WAAY,CAAA,EAAM,IAAK,CAAU,CAAC,EAAI,AAAC,EAGhF,CACD,CAAA,IAGC,AAAA,CAAA,KACA,oBAAoB,CAAC,CAAG,CAAC,EAAK,IAAU,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAK,EACnF,CAAA,IAGC,AAAA,CAAA,KAEA,oBAAoB,CAAC,CAAG,AAAC,IACH,aAAlB,OAAO,QAA0B,OAAO,WAAW,EACrD,OAAO,cAAc,CAAC,EAAS,OAAO,WAAW,CAAE,CAAE,MAAO,QAAS,GAEtE,OAAO,cAAc,CAAC,EAAS,aAAc,CAAE,MAAO,CAAA,CAAK,EAC5D,CACD,CAAA,IAOA,IAAI,oBAAsB,oBAAoB,oBAE/C,CAAA","sources":["<anon>","src/js/index.js"],"sourcesContent":["/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */ /******/ (()=>{\n    /******/ \"use strict\";\n    /******/ var __webpack_modules__ = {\n        /***/ \"./src/ts/index.ts\": /*!*************************!*\\\n  !*** ./src/ts/index.ts ***!\n  \\*************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n            eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shapes */ \\\"./src/ts/shapes.ts\\\");\\n\\n// === \\u041E\\u0431\\u044A\\u044F\\u0432\\u043B\\u0435\\u043D\\u0438\\u0435 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u0439 ===\\n// \\u0424\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u0434\\u043B\\u044F \\u043E\\u0442\\u0440\\u0438\\u0441\\u043E\\u0432\\u043A\\u0438 \\u0438\\u0433\\u0440\\u043E\\u0432\\u043E\\u0433\\u043E \\u043F\\u043E\\u043B\\u044F\\nfunction drawTetrisPlayground(x, y, target) {\\n    if (x <= 0 || y <= 0)\\n        throw new Error('x and y cannot be negative');\\n    if (target.children.length)\\n        throw new Error('Aborted: target element should be empty');\\n    for (let rowsCount = 0; rowsCount < y; rowsCount++) {\\n        const row = document.createElement('div');\\n        row.className = 'row';\\n        row.dataset['row'] = rowsCount.toString();\\n        for (let cellsCount = 0; cellsCount < x; cellsCount++) {\\n            const cell = document.createElement('div');\\n            cell.className = 'cell';\\n            cell.dataset['cell'] = cellsCount.toString();\\n            row.append(cell);\\n        }\\n        target.append(row);\\n    }\\n}\\n// \\u0424\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u0434\\u043B\\u044F \\u043E\\u0442\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u044F \\u0437\\u0430\\u0444\\u0438\\u043A\\u0441\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u044B\\u0445 \\u0431\\u043B\\u043E\\u043A\\u043E\\u0432 \\u043D\\u0430 \\u0438\\u0433\\u0440\\u043E\\u0432\\u043E\\u043C \\u043F\\u043E\\u043B\\u0435\\nfunction renderFixedBlocks() {\\n    var _a;\\n    for (let row = 0; row < playground.length; row++) {\\n        for (let col = 0; col < playground[row].length; col++) {\\n            const cell = (_a = tetrisPlaygroundTarget === null || tetrisPlaygroundTarget === void 0 ? void 0 : tetrisPlaygroundTarget.children[row]) === null || _a === void 0 ? void 0 : _a.children[col];\\n            if (!cell)\\n                continue;\\n            // \\u0415\\u0441\\u043B\\u0438 \\u0431\\u043B\\u043E\\u043A \\u0437\\u0430\\u0444\\u0438\\u043A\\u0441\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D, \\u043E\\u0442\\u043E\\u0431\\u0440\\u0430\\u0437\\u0438\\u043C \\u0435\\u0433\\u043E \\u0446\\u0432\\u0435\\u0442, \\u0438\\u043D\\u0430\\u0447\\u0435 \\u043E\\u0447\\u0438\\u0441\\u0442\\u0438\\u043C \\u044F\\u0447\\u0435\\u0439\\u043A\\u0443\\n            if (playground[row][col]) {\\n                cell.style.backgroundColor = 'grey';\\n            }\\n            else {\\n                cell.style.backgroundColor = '';\\n            }\\n        }\\n    }\\n}\\n// \\u0424\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u0434\\u043B\\u044F \\u043E\\u0442\\u043E\\u0431\\u0440\\u0430\\u0436\\u0435\\u043D\\u0438\\u044F \\u0434\\u0432\\u0438\\u0436\\u0443\\u0449\\u0435\\u0439\\u0441\\u044F \\u0444\\u0438\\u0433\\u0443\\u0440\\u044B \\u043D\\u0430 \\u0438\\u0433\\u0440\\u043E\\u0432\\u043E\\u043C \\u043F\\u043E\\u043B\\u0435\\nfunction renderShape() {\\n    var _a;\\n    const rowsToColor = currentShape.shape.length;\\n    const cellsToColor = currentShape.shape[0].length;\\n    for (let rowIndex = 0; rowIndex < rowsToColor; rowIndex++) {\\n        for (let cellIndex = 0; cellIndex < cellsToColor; cellIndex++) {\\n            if (currentShape.shape[rowIndex][cellIndex]) {\\n                const x = currentX + cellIndex;\\n                const y = currentY + rowIndex;\\n                // \\u041F\\u0440\\u043E\\u0432\\u0435\\u0440\\u044F\\u0435\\u043C, \\u043D\\u0435 \\u0432\\u044B\\u0445\\u043E\\u0434\\u0438\\u0442 \\u043B\\u0438 \\u0437\\u0430 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u044B\\n                if (x >= 0 && x < 10 && y >= 0 && y < 20) {\\n                    const cell = (_a = tetrisPlaygroundTarget === null || tetrisPlaygroundTarget === void 0 ? void 0 : tetrisPlaygroundTarget.children[y]) === null || _a === void 0 ? void 0 : _a.children[x];\\n                    if (cell) {\\n                        cell.style.backgroundColor = currentShape.color;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n// \\u0424\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u0434\\u043B\\u044F \\u0443\\u0434\\u0430\\u043B\\u0435\\u043D\\u0438\\u044F \\u043F\\u0440\\u0435\\u0434\\u044B\\u0434\\u0443\\u0449\\u0435\\u0433\\u043E \\u0441\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u044F \\u0434\\u0432\\u0438\\u0436\\u0443\\u0449\\u0435\\u0439\\u0441\\u044F \\u0444\\u0438\\u0433\\u0443\\u0440\\u044B\\nfunction removePreviousShape() {\\n    var _a;\\n    const rowsToClear = currentShape.shape.length;\\n    const cellsToClear = currentShape.shape[0].length;\\n    for (let rowIndex = 0; rowIndex < rowsToClear; rowIndex++) {\\n        for (let cellIndex = 0; cellIndex < cellsToClear; cellIndex++) {\\n            if (currentShape.shape[rowIndex][cellIndex]) {\\n                const x = currentX + cellIndex;\\n                const y = currentY + rowIndex;\\n                // \\u041F\\u0440\\u043E\\u0432\\u0435\\u0440\\u044F\\u0435\\u043C, \\u043D\\u0435 \\u0432\\u044B\\u0445\\u043E\\u0434\\u0438\\u0442 \\u043B\\u0438 \\u0437\\u0430 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u044B\\n                if (x >= 0 && x < 10 && y >= 0 && y < 20) {\\n                    // \\u041E\\u0447\\u0438\\u0449\\u0430\\u0435\\u043C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0435\\u0441\\u043B\\u0438 \\u0437\\u0434\\u0435\\u0441\\u044C \\u043D\\u0435\\u0442 \\u0437\\u0430\\u0444\\u0438\\u043A\\u0441\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u043E\\u0433\\u043E \\u0431\\u043B\\u043E\\u043A\\u0430\\n                    if (!playground[y][x]) {\\n                        const cell = (_a = tetrisPlaygroundTarget === null || tetrisPlaygroundTarget === void 0 ? void 0 : tetrisPlaygroundTarget.children[y]) === null || _a === void 0 ? void 0 : _a.children[x];\\n                        if (cell) {\\n                            cell.style.backgroundColor = '';\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n// \\u0424\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u0434\\u043B\\u044F \\u043F\\u043E\\u0432\\u043E\\u0440\\u043E\\u0442\\u0430 \\u0444\\u0438\\u0433\\u0443\\u0440\\u044B \\u043D\\u0430 90 \\u0433\\u0440\\u0430\\u0434\\u0443\\u0441\\u043E\\u0432\\nfunction rotateShape(shape) {\\n    const rotatedShape = [];\\n    const rows = shape.length;\\n    const cols = shape[0].length;\\n    for (let col = 0; col < cols; col++) {\\n        rotatedShape[col] = [];\\n        for (let row = rows - 1; row >= 0; row--) {\\n            rotatedShape[col][rows - 1 - row] = shape[row][col];\\n        }\\n    }\\n    return rotatedShape;\\n}\\n// \\u0424\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u0434\\u043B\\u044F \\u043F\\u0435\\u0440\\u0435\\u043C\\u0435\\u0449\\u0435\\u043D\\u0438\\u044F \\u0444\\u0438\\u0433\\u0443\\u0440\\u044B \\u0432\\u043B\\u0435\\u0432\\u043E \\u0438 \\u0432\\u043F\\u0440\\u0430\\u0432\\u043E\\nfunction moveShape(direction) {\\n    if (!isCollision(currentShape.shape, currentX + direction, currentY)) {\\n        removePreviousShape();\\n        currentX += direction;\\n        renderShape();\\n    }\\n}\\n// \\u0424\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u0434\\u043B\\u044F \\u0441\\u043E\\u0437\\u0434\\u0430\\u043D\\u0438\\u044F \\u0438\\u0433\\u0440\\u043E\\u0432\\u043E\\u0433\\u043E \\u043F\\u043E\\u043B\\u044F \\u043A\\u0430\\u043A \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430\\nfunction createPlayground() {\\n    const playground = [];\\n    for (let row = 0; row < 20; row++) {\\n        playground[row] = new Array(10).fill(0);\\n    }\\n    return playground;\\n}\\n// \\u0424\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u0434\\u043B\\u044F \\u0433\\u0435\\u043D\\u0435\\u0440\\u0430\\u0446\\u0438\\u0438 \\u043D\\u043E\\u0432\\u043E\\u0439 \\u0444\\u0438\\u0433\\u0443\\u0440\\u044B\\nfunction generateNewShape() {\\n    const shapeKeyIndex = Math.floor(Math.random() * shapeKeys.length);\\n    const shapeKey = shapeKeys[shapeKeyIndex];\\n    currentShape.shape = _shapes__WEBPACK_IMPORTED_MODULE_0__.shapes[shapeKey].shape;\\n    currentShape.color = _shapes__WEBPACK_IMPORTED_MODULE_0__.shapes[shapeKey].color;\\n    currentX = 3;\\n    currentY = 0;\\n}\\n// \\u041F\\u0440\\u043E\\u0432\\u0435\\u0440\\u043A\\u0430 \\u0441\\u0442\\u043E\\u043B\\u043A\\u043D\\u043E\\u0432\\u0435\\u043D\\u0438\\u044F \\u0444\\u0438\\u0433\\u0443\\u0440\\u044B \\u0441 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u0430\\u043C\\u0438 \\u0438\\u043B\\u0438 \\u0434\\u0440\\u0443\\u0433\\u0438\\u043C\\u0438 \\u0444\\u0438\\u0433\\u0443\\u0440\\u0430\\u043C\\u0438\\nfunction isCollision(shape, x, y) {\\n    for (let row = 0; row < shape.length; row++) {\\n        for (let col = 0; col < shape[row].length; col++) {\\n            if (shape[row][col]) {\\n                const newX = x + col;\\n                const newY = y + row;\\n                // \\u041F\\u0440\\u043E\\u0432\\u0435\\u0440\\u044F\\u0435\\u043C \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u044B \\u043F\\u043E\\u043B\\u044F\\n                if (newX < 0 || newX >= 10 || newY >= 20) {\\n                    return true;\\n                }\\n                // \\u041F\\u0440\\u043E\\u0432\\u0435\\u0440\\u044F\\u0435\\u043C \\u043D\\u0430 \\u0441\\u0442\\u043E\\u043B\\u043A\\u043D\\u043E\\u0432\\u0435\\u043D\\u0438\\u0435 \\u0441 \\u0437\\u0430\\u0444\\u0438\\u043A\\u0441\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u044B\\u043C\\u0438 \\u0431\\u043B\\u043E\\u043A\\u0430\\u043C\\u0438\\n                if (playground[newY][newX]) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n}\\n// \\u0424\\u0438\\u043A\\u0441\\u0430\\u0446\\u0438\\u044F \\u0444\\u0438\\u0433\\u0443\\u0440\\u044B \\u043D\\u0430 \\u0438\\u0433\\u0440\\u043E\\u0432\\u043E\\u043C \\u043F\\u043E\\u043B\\u0435\\nfunction fixShape() {\\n    for (let row = 0; row < currentShape.shape.length; row++) {\\n        for (let col = 0; col < currentShape.shape[row].length; col++) {\\n            if (currentShape.shape[row][col]) {\\n                playground[currentY + row][currentX + col] = 1;\\n            }\\n        }\\n    }\\n}\\n// \\u0424\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u0434\\u043B\\u044F \\u0443\\u0434\\u0430\\u043B\\u0435\\u043D\\u0438\\u044F \\u0437\\u0430\\u043F\\u043E\\u043B\\u043D\\u0435\\u043D\\u043D\\u044B\\u0445 \\u043B\\u0438\\u043D\\u0438\\u0439\\nfunction removeFullLines() {\\n    for (let row = playground.length - 1; row >= 0; row--) {\\n        if (playground[row].every((cell) => cell === 1)) {\\n            playground.splice(row, 1);\\n            playground.unshift(new Array(10).fill(0));\\n        }\\n    }\\n    renderFixedBlocks();\\n}\\n// === \\u041D\\u0430\\u0447\\u0430\\u043B\\u043E \\u0432\\u044B\\u043F\\u043E\\u043B\\u043D\\u0435\\u043D\\u0438\\u044F \\u043F\\u0440\\u043E\\u0433\\u0440\\u0430\\u043C\\u043C\\u044B ===\\n// \\u0418\\u043D\\u0438\\u0446\\u0438\\u0430\\u043B\\u0438\\u0437\\u0438\\u0440\\u0443\\u0435\\u043C \\u0438\\u0433\\u0440\\u043E\\u0432\\u043E\\u0435 \\u043F\\u043E\\u043B\\u0435\\nconst tetrisPlaygroundTarget = document.querySelector('.tetris-playground');\\nif (tetrisPlaygroundTarget) {\\n    drawTetrisPlayground(10, 20, tetrisPlaygroundTarget);\\n}\\n// \\u041F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u043C \\u043A\\u043B\\u044E\\u0447\\u0438 \\u0444\\u0438\\u0433\\u0443\\u0440\\nconst shapeKeys = Object.keys(_shapes__WEBPACK_IMPORTED_MODULE_0__.shapes);\\n// \\u0418\\u043D\\u0438\\u0446\\u0438\\u0430\\u043B\\u0438\\u0437\\u0438\\u0440\\u0443\\u0435\\u043C \\u0442\\u0435\\u043A\\u0443\\u0449\\u0443\\u044E \\u0444\\u0438\\u0433\\u0443\\u0440\\u0443\\nconst currentShape = {\\n    shape: _shapes__WEBPACK_IMPORTED_MODULE_0__.shapes['T'].shape,\\n    color: _shapes__WEBPACK_IMPORTED_MODULE_0__.shapes['T'].color,\\n};\\nlet currentX = 3;\\nlet currentY = 0;\\nlet speed = 1000; // \\u041D\\u0430\\u0447\\u0430\\u043B\\u044C\\u043D\\u0430\\u044F \\u0441\\u043A\\u043E\\u0440\\u043E\\u0441\\u0442\\u044C\\nlet isPaused = false;\\nconst playground = createPlayground();\\n// \\u041E\\u0442\\u043E\\u0431\\u0440\\u0430\\u0436\\u0430\\u0435\\u043C \\u043D\\u0430\\u0447\\u0430\\u043B\\u044C\\u043D\\u0443\\u044E \\u0444\\u0438\\u0433\\u0443\\u0440\\u0443\\nrenderShape();\\n// \\u041E\\u0441\\u043D\\u043E\\u0432\\u043D\\u043E\\u0439 \\u0438\\u0433\\u0440\\u043E\\u0432\\u043E\\u0439 \\u0446\\u0438\\u043A\\u043B\\nfunction gameLoop() {\\n    setTimeout(() => {\\n        if (!isPaused) {\\n            if (!isCollision(currentShape.shape, currentX, currentY + 1)) {\\n                removePreviousShape();\\n                currentY++;\\n                renderShape();\\n            }\\n            else {\\n                fixShape();\\n                removeFullLines();\\n                generateNewShape();\\n                if (isCollision(currentShape.shape, currentX, currentY)) {\\n                    alert('\\u0418\\u0433\\u0440\\u0430 \\u043E\\u043A\\u043E\\u043D\\u0447\\u0435\\u043D\\u0430');\\n                    return;\\n                }\\n                renderShape();\\n            }\\n        }\\n        gameLoop();\\n    }, speed);\\n}\\n// \\u0417\\u0430\\u043F\\u0443\\u0441\\u043A\\u0430\\u0435\\u043C \\u0438\\u0433\\u0440\\u043E\\u0432\\u043E\\u0439 \\u0446\\u0438\\u043A\\u043B\\ngameLoop();\\n// \\u041E\\u0431\\u0440\\u0430\\u0431\\u043E\\u0442\\u0447\\u0438\\u043A \\u043A\\u043B\\u0430\\u0432\\u0438\\u0448 \\u0434\\u043B\\u044F \\u0443\\u043F\\u0440\\u0430\\u0432\\u043B\\u0435\\u043D\\u0438\\u044F \\u0444\\u0438\\u0433\\u0443\\u0440\\u043E\\u0439\\ndocument.addEventListener('keydown', (e) => {\\n    if (e.code === 'Space') {\\n        const newShape = rotateShape(currentShape.shape);\\n        if (!isCollision(newShape, currentX, currentY)) {\\n            removePreviousShape();\\n            currentShape.shape = newShape;\\n            renderShape();\\n        }\\n    }\\n    else if (e.code === 'ArrowLeft') {\\n        moveShape(-1);\\n    }\\n    else if (e.code === 'ArrowRight') {\\n        moveShape(1);\\n    }\\n    else if (e.code === 'ArrowDown') {\\n        speed = 100; // \\u0423\\u0441\\u043A\\u043E\\u0440\\u044F\\u0435\\u043C \\u043F\\u0430\\u0434\\u0435\\u043D\\u0438\\u0435 \\u0444\\u0438\\u0433\\u0443\\u0440\\u044B\\n    }\\n});\\n// \\u041E\\u0431\\u0440\\u0430\\u0431\\u043E\\u0442\\u0447\\u0438\\u043A \\u043E\\u0442\\u043F\\u0443\\u0441\\u043A\\u0430\\u043D\\u0438\\u044F \\u043A\\u043B\\u0430\\u0432\\u0438\\u0448\\ndocument.addEventListener('keyup', (e) => {\\n    if (e.code === 'ArrowDown') {\\n        speed = 1000; // \\u0412\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u043C \\u0441\\u0442\\u0430\\u043D\\u0434\\u0430\\u0440\\u0442\\u043D\\u0443\\u044E \\u0441\\u043A\\u043E\\u0440\\u043E\\u0441\\u0442\\u044C\\n    }\\n});\\n\\n\\n//# sourceURL=webpack:///./src/ts/index.ts?\");\n        /***/ },\n        /***/ \"./src/ts/shapes.ts\": /*!**************************!*\\\n  !*** ./src/ts/shapes.ts ***!\n  \\**************************/ /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{\n            eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   shapes: () => (/* binding */ shapes)\\n/* harmony export */ });\\nconst shapes = {\\n    S: {\\n        shape: [\\n            [0, 1, 1],\\n            [1, 1, 0],\\n        ],\\n        color: 'yellowgreen',\\n    },\\n    Z: {\\n        shape: [\\n            [1, 1, 0],\\n            [0, 1, 1],\\n        ],\\n        color: 'red',\\n    },\\n    T: {\\n        shape: [\\n            [1, 1, 1],\\n            [0, 1, 0],\\n        ],\\n        color: 'purple',\\n    },\\n    O: {\\n        shape: [\\n            [1, 1],\\n            [1, 1],\\n        ],\\n        color: 'yellow',\\n    },\\n    J: {\\n        shape: [\\n            [0, 1],\\n            [0, 1],\\n            [1, 1],\\n        ],\\n        color: 'blue',\\n    },\\n    L: {\\n        shape: [\\n            [1, 0],\\n            [1, 0],\\n            [1, 1],\\n        ],\\n        color: 'orange',\\n    },\\n    I: {\\n        shape: [[1], [1], [1], [1]],\\n        color: 'aqua',\\n    },\\n};\\n\\n\\n//# sourceURL=webpack:///./src/ts/shapes.ts?\");\n        /***/ }\n    };\n    /************************************************************************/ /******/ // The module cache\n    /******/ var __webpack_module_cache__ = {};\n    /******/ /******/ // The require function\n    /******/ function __webpack_require__(moduleId) {\n        /******/ // Check if module is in cache\n        /******/ var cachedModule = __webpack_module_cache__[moduleId];\n        /******/ if (cachedModule !== undefined) /******/ return cachedModule.exports;\n        /******/ // Create a new module (and put it into the cache)\n        /******/ var module = __webpack_module_cache__[moduleId] = {\n            /******/ // no module.id needed\n            /******/ // no module.loaded needed\n            /******/ exports: {}\n        };\n        /******/ /******/ // Execute the module function\n        /******/ __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n        /******/ /******/ // Return the exports of the module\n        /******/ return module.exports;\n    /******/ }\n    /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n        /******/ // define getter functions for harmony exports\n        /******/ __webpack_require__.d = (exports, definition)=>{\n            /******/ for(var key in definition)/******/ if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) /******/ Object.defineProperty(exports, key, {\n                enumerable: true,\n                get: definition[key]\n            });\n        /******/ };\n    /******/ })();\n    /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n        /******/ __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n    /******/ })();\n    /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{\n        /******/ // define __esModule on exports\n        /******/ __webpack_require__.r = (exports)=>{\n            /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) /******/ Object.defineProperty(exports, Symbol.toStringTag, {\n                value: 'Module'\n            });\n            /******/ Object.defineProperty(exports, '__esModule', {\n                value: true\n            });\n        /******/ };\n    /******/ })();\n    /******/ /************************************************************************/ /******/ /******/ // startup\n    /******/ // Load entry module and return exports\n    /******/ // This entry module can't be inlined because the eval devtool is used.\n    /******/ var __webpack_exports__ = __webpack_require__(\"./src/ts/index.ts\");\n/******/ /******/ })();\n\n//# sourceMappingURL=index.dea492de.js.map\n","/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./src/ts/index.ts\":\n/*!*************************!*\\\n  !*** ./src/ts/index.ts ***!\n  \\*************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shapes */ \\\"./src/ts/shapes.ts\\\");\\n\\n// === Объявление функций ===\\n// Функция для отрисовки игрового поля\\nfunction drawTetrisPlayground(x, y, target) {\\n    if (x <= 0 || y <= 0)\\n        throw new Error('x and y cannot be negative');\\n    if (target.children.length)\\n        throw new Error('Aborted: target element should be empty');\\n    for (let rowsCount = 0; rowsCount < y; rowsCount++) {\\n        const row = document.createElement('div');\\n        row.className = 'row';\\n        row.dataset['row'] = rowsCount.toString();\\n        for (let cellsCount = 0; cellsCount < x; cellsCount++) {\\n            const cell = document.createElement('div');\\n            cell.className = 'cell';\\n            cell.dataset['cell'] = cellsCount.toString();\\n            row.append(cell);\\n        }\\n        target.append(row);\\n    }\\n}\\n// Функция для отображения зафиксированных блоков на игровом поле\\nfunction renderFixedBlocks() {\\n    var _a;\\n    for (let row = 0; row < playground.length; row++) {\\n        for (let col = 0; col < playground[row].length; col++) {\\n            const cell = (_a = tetrisPlaygroundTarget === null || tetrisPlaygroundTarget === void 0 ? void 0 : tetrisPlaygroundTarget.children[row]) === null || _a === void 0 ? void 0 : _a.children[col];\\n            if (!cell)\\n                continue;\\n            // Если блок зафиксирован, отобразим его цвет, иначе очистим ячейку\\n            if (playground[row][col]) {\\n                cell.style.backgroundColor = 'grey';\\n            }\\n            else {\\n                cell.style.backgroundColor = '';\\n            }\\n        }\\n    }\\n}\\n// Функция для отображения движущейся фигуры на игровом поле\\nfunction renderShape() {\\n    var _a;\\n    const rowsToColor = currentShape.shape.length;\\n    const cellsToColor = currentShape.shape[0].length;\\n    for (let rowIndex = 0; rowIndex < rowsToColor; rowIndex++) {\\n        for (let cellIndex = 0; cellIndex < cellsToColor; cellIndex++) {\\n            if (currentShape.shape[rowIndex][cellIndex]) {\\n                const x = currentX + cellIndex;\\n                const y = currentY + rowIndex;\\n                // Проверяем, не выходит ли за границы\\n                if (x >= 0 && x < 10 && y >= 0 && y < 20) {\\n                    const cell = (_a = tetrisPlaygroundTarget === null || tetrisPlaygroundTarget === void 0 ? void 0 : tetrisPlaygroundTarget.children[y]) === null || _a === void 0 ? void 0 : _a.children[x];\\n                    if (cell) {\\n                        cell.style.backgroundColor = currentShape.color;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n// Функция для удаления предыдущего состояния движущейся фигуры\\nfunction removePreviousShape() {\\n    var _a;\\n    const rowsToClear = currentShape.shape.length;\\n    const cellsToClear = currentShape.shape[0].length;\\n    for (let rowIndex = 0; rowIndex < rowsToClear; rowIndex++) {\\n        for (let cellIndex = 0; cellIndex < cellsToClear; cellIndex++) {\\n            if (currentShape.shape[rowIndex][cellIndex]) {\\n                const x = currentX + cellIndex;\\n                const y = currentY + rowIndex;\\n                // Проверяем, не выходит ли за границы\\n                if (x >= 0 && x < 10 && y >= 0 && y < 20) {\\n                    // Очищаем только если здесь нет зафиксированного блока\\n                    if (!playground[y][x]) {\\n                        const cell = (_a = tetrisPlaygroundTarget === null || tetrisPlaygroundTarget === void 0 ? void 0 : tetrisPlaygroundTarget.children[y]) === null || _a === void 0 ? void 0 : _a.children[x];\\n                        if (cell) {\\n                            cell.style.backgroundColor = '';\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n// Функция для поворота фигуры на 90 градусов\\nfunction rotateShape(shape) {\\n    const rotatedShape = [];\\n    const rows = shape.length;\\n    const cols = shape[0].length;\\n    for (let col = 0; col < cols; col++) {\\n        rotatedShape[col] = [];\\n        for (let row = rows - 1; row >= 0; row--) {\\n            rotatedShape[col][rows - 1 - row] = shape[row][col];\\n        }\\n    }\\n    return rotatedShape;\\n}\\n// Функция для перемещения фигуры влево и вправо\\nfunction moveShape(direction) {\\n    if (!isCollision(currentShape.shape, currentX + direction, currentY)) {\\n        removePreviousShape();\\n        currentX += direction;\\n        renderShape();\\n    }\\n}\\n// Функция для создания игрового поля как массива\\nfunction createPlayground() {\\n    const playground = [];\\n    for (let row = 0; row < 20; row++) {\\n        playground[row] = new Array(10).fill(0);\\n    }\\n    return playground;\\n}\\n// Функция для генерации новой фигуры\\nfunction generateNewShape() {\\n    const shapeKeyIndex = Math.floor(Math.random() * shapeKeys.length);\\n    const shapeKey = shapeKeys[shapeKeyIndex];\\n    currentShape.shape = _shapes__WEBPACK_IMPORTED_MODULE_0__.shapes[shapeKey].shape;\\n    currentShape.color = _shapes__WEBPACK_IMPORTED_MODULE_0__.shapes[shapeKey].color;\\n    currentX = 3;\\n    currentY = 0;\\n}\\n// Проверка столкновения фигуры с границами или другими фигурами\\nfunction isCollision(shape, x, y) {\\n    for (let row = 0; row < shape.length; row++) {\\n        for (let col = 0; col < shape[row].length; col++) {\\n            if (shape[row][col]) {\\n                const newX = x + col;\\n                const newY = y + row;\\n                // Проверяем границы поля\\n                if (newX < 0 || newX >= 10 || newY >= 20) {\\n                    return true;\\n                }\\n                // Проверяем на столкновение с зафиксированными блоками\\n                if (playground[newY][newX]) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n}\\n// Фиксация фигуры на игровом поле\\nfunction fixShape() {\\n    for (let row = 0; row < currentShape.shape.length; row++) {\\n        for (let col = 0; col < currentShape.shape[row].length; col++) {\\n            if (currentShape.shape[row][col]) {\\n                playground[currentY + row][currentX + col] = 1;\\n            }\\n        }\\n    }\\n}\\n// Функция для удаления заполненных линий\\nfunction removeFullLines() {\\n    for (let row = playground.length - 1; row >= 0; row--) {\\n        if (playground[row].every((cell) => cell === 1)) {\\n            playground.splice(row, 1);\\n            playground.unshift(new Array(10).fill(0));\\n        }\\n    }\\n    renderFixedBlocks();\\n}\\n// === Начало выполнения программы ===\\n// Инициализируем игровое поле\\nconst tetrisPlaygroundTarget = document.querySelector('.tetris-playground');\\nif (tetrisPlaygroundTarget) {\\n    drawTetrisPlayground(10, 20, tetrisPlaygroundTarget);\\n}\\n// Получаем ключи фигур\\nconst shapeKeys = Object.keys(_shapes__WEBPACK_IMPORTED_MODULE_0__.shapes);\\n// Инициализируем текущую фигуру\\nconst currentShape = {\\n    shape: _shapes__WEBPACK_IMPORTED_MODULE_0__.shapes['T'].shape,\\n    color: _shapes__WEBPACK_IMPORTED_MODULE_0__.shapes['T'].color,\\n};\\nlet currentX = 3;\\nlet currentY = 0;\\nlet speed = 1000; // Начальная скорость\\nlet isPaused = false;\\nconst playground = createPlayground();\\n// Отображаем начальную фигуру\\nrenderShape();\\n// Основной игровой цикл\\nfunction gameLoop() {\\n    setTimeout(() => {\\n        if (!isPaused) {\\n            if (!isCollision(currentShape.shape, currentX, currentY + 1)) {\\n                removePreviousShape();\\n                currentY++;\\n                renderShape();\\n            }\\n            else {\\n                fixShape();\\n                removeFullLines();\\n                generateNewShape();\\n                if (isCollision(currentShape.shape, currentX, currentY)) {\\n                    alert('Игра окончена');\\n                    return;\\n                }\\n                renderShape();\\n            }\\n        }\\n        gameLoop();\\n    }, speed);\\n}\\n// Запускаем игровой цикл\\ngameLoop();\\n// Обработчик клавиш для управления фигурой\\ndocument.addEventListener('keydown', (e) => {\\n    if (e.code === 'Space') {\\n        const newShape = rotateShape(currentShape.shape);\\n        if (!isCollision(newShape, currentX, currentY)) {\\n            removePreviousShape();\\n            currentShape.shape = newShape;\\n            renderShape();\\n        }\\n    }\\n    else if (e.code === 'ArrowLeft') {\\n        moveShape(-1);\\n    }\\n    else if (e.code === 'ArrowRight') {\\n        moveShape(1);\\n    }\\n    else if (e.code === 'ArrowDown') {\\n        speed = 100; // Ускоряем падение фигуры\\n    }\\n});\\n// Обработчик отпускания клавиш\\ndocument.addEventListener('keyup', (e) => {\\n    if (e.code === 'ArrowDown') {\\n        speed = 1000; // Возвращаем стандартную скорость\\n    }\\n});\\n\\n\\n//# sourceURL=webpack:///./src/ts/index.ts?\");\n\n/***/ }),\n\n/***/ \"./src/ts/shapes.ts\":\n/*!**************************!*\\\n  !*** ./src/ts/shapes.ts ***!\n  \\**************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   shapes: () => (/* binding */ shapes)\\n/* harmony export */ });\\nconst shapes = {\\n    S: {\\n        shape: [\\n            [0, 1, 1],\\n            [1, 1, 0],\\n        ],\\n        color: 'yellowgreen',\\n    },\\n    Z: {\\n        shape: [\\n            [1, 1, 0],\\n            [0, 1, 1],\\n        ],\\n        color: 'red',\\n    },\\n    T: {\\n        shape: [\\n            [1, 1, 1],\\n            [0, 1, 0],\\n        ],\\n        color: 'purple',\\n    },\\n    O: {\\n        shape: [\\n            [1, 1],\\n            [1, 1],\\n        ],\\n        color: 'yellow',\\n    },\\n    J: {\\n        shape: [\\n            [0, 1],\\n            [0, 1],\\n            [1, 1],\\n        ],\\n        color: 'blue',\\n    },\\n    L: {\\n        shape: [\\n            [1, 0],\\n            [1, 0],\\n            [1, 1],\\n        ],\\n        color: 'orange',\\n    },\\n    I: {\\n        shape: [[1], [1], [1], [1]],\\n        color: 'aqua',\\n    },\\n};\\n\\n\\n//# sourceURL=webpack:///./src/ts/shapes.ts?\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__webpack_require__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module can't be inlined because the eval devtool is used.\n/******/ \tvar __webpack_exports__ = __webpack_require__(\"./src/ts/index.ts\");\n/******/ \t\n/******/ })()\n;"],"names":["__webpack_modules__","__unused_webpack_module","__webpack_exports__","__webpack_require__","eval","__webpack_module_cache__","moduleId","cachedModule","undefined","exports","module","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value"],"version":3,"file":"index.dea492de.js.map"}